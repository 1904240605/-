/*描述
约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、
由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到中间的杆上，条件是一次只
能移动一个盘，且不允许大盘放在小盘的上面。 这是一个著名的问题，几乎所有的教材上都有这个问题。
由于条件是一次只能移动一个盘，且不允许大盘放在小盘上面，所以64个盘的移动次数是：
18,446,744,073,709,551,615这是一个天文数字，若每一微秒可能计算(并不输出)一次移动，那么也
需要几乎一百万年。我们仅能找出问题的解决方法并解决较小N值时的汉诺塔，但很难用计算机解决64层
的汉诺塔。 

假定圆盘从小到大编号为1, 2, ...

输入
输入为一个整数后面跟三个单字符字符串。
整数为盘子的数目，后三个字符表示三个杆子的编号。
输出
输出每一步移动盘子的记录。一次移动一行。
每次移动的记录为例如 a->3->b 的形式，即把编号为3的盘子从a杆移至b杆。*/
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
int tot=0;
void ha2(int n,char a,char b,char c) {
    if(n==0)return;
    ha2(n-1,a,c,b);
    cout<<a<<"->"<<n<<"->"<<b<<endl;
    ha2(n-1,c,b,a);
}
int main() {
    int n;
    char a,b,c;
    cin>>n;
    cin>>a>>b>>c;
    ha2(n,a,b,c);
    return 0;
}
